"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var convert_1 = __importDefault(require("./util/convert"));
//@ts-ignore
var blakejs_1 = require("blakejs");
var NanoAddress = /** @class */ (function () {
    function NanoAddress() {
        var _this = this;
        this.alphabet = '13456789abcdefghijkmnopqrstuwxyz';
        this.prefix = 'nano_';
        this.deriveAddress = function (publicKey) {
            var publicKeyBytes = convert_1.default.hex2ab(publicKey);
            var checksum = blakejs_1.blake2b(publicKeyBytes, undefined, 5).reverse();
            var encoded = _this.encodeNanoBase32(publicKeyBytes);
            var encodedChecksum = _this.encodeNanoBase32(checksum);
            return _this.prefix + encoded + encodedChecksum;
        };
        this.encodeNanoBase32 = function (publicKey) {
            var length = publicKey.length;
            var leftover = (length * 8) % 5;
            var offset = leftover === 0 ? 0 : 5 - leftover;
            var value = 0;
            var output = '';
            var bits = 0;
            for (var i = 0; i < length; i++) {
                value = (value << 8) | publicKey[i];
                bits += 8;
                while (bits >= 5) {
                    output += _this.alphabet[(value >>> (bits + offset - 5)) & 31];
                    bits -= 5;
                }
            }
            if (bits > 0) {
                output += _this.alphabet[(value << (5 - (bits + offset))) & 31];
            }
            return output;
        };
        this.decodeNanoBase32 = function (input) {
            var length = input.length;
            var leftover = (length * 5) % 8;
            var offset = leftover === 0 ? 0 : 8 - leftover;
            var bits = 0;
            var value = 0;
            var index = 0;
            var output = new Uint8Array(Math.ceil((length * 5) / 8));
            for (var i = 0; i < length; i++) {
                value = (value << 5) | _this.readChar(input[i]);
                bits += 5;
                if (bits >= 8) {
                    output[index++] = (value >>> (bits + offset - 8)) & 255;
                    bits -= 8;
                }
            }
            if (bits > 0) {
                output[index++] = (value << (bits + offset - 8)) & 255;
            }
            if (leftover !== 0) {
                output = output.slice(1);
            }
            return output;
        };
        /**
         * Validates a Nano address with 'nano' and 'xrb' prefixes
         *
         * Derived from https://github.com/alecrios/nano-address-validator
         *
         * @param {string} address Nano address
         */
        this.validateNanoAddress = function (address) {
            /** Ensure the address is provided */
            if (address === undefined) {
                throw Error('Address must be defined.');
            }
            /** Ensure the address is a string */
            if (typeof address !== 'string') {
                throw TypeError('Address must be a string.');
            }
            /** The array of allowed prefixes */
            var allowedPrefixes = ['nano', 'xrb'];
            /** The regex pattern for validating the address */
            var pattern = new RegExp("^(" + allowedPrefixes.join('|') + ")_[13]{1}[13456789abcdefghijkmnopqrstuwxyz]{59}$");
            /** Validate the syntax of the address */
            if (!pattern.test(address))
                return false;
            /** The expected checksum as a base32-encoded string */
            var expectedChecksum = address.slice(-8);
            /** The public key as a base32-encoded string */
            var publicKey = address.slice(address.indexOf('_') + 1, -8);
            /** The public key as an array buffer */
            var publicKeyBuffer = _this.decodeNanoBase32(publicKey);
            /** The actual checksum as an array buffer */
            var actualChecksumBuffer = blakejs_1.blake2b(publicKeyBuffer, null, 5).reverse();
            /** The actual checksum as a base32-encoded string */
            var actualChecksum = _this.encodeNanoBase32(actualChecksumBuffer);
            /** Validate the provided checksum against the derived checksum */
            return expectedChecksum === actualChecksum;
        };
    }
    NanoAddress.prototype.readChar = function (char) {
        var idx = this.alphabet.indexOf(char);
        if (idx === -1) {
            throw new Error("Invalid character found: " + char);
        }
        return idx;
    };
    return NanoAddress;
}());
exports.default = NanoAddress;
