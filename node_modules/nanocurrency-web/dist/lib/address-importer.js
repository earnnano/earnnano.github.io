"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var bip32_key_derivation_1 = __importDefault(require("./bip32-key-derivation"));
var bip39_mnemonic_1 = __importDefault(require("./bip39-mnemonic"));
var ed25519_1 = __importDefault(require("./ed25519"));
var nano_address_1 = __importDefault(require("./nano-address"));
var AddressImporter = /** @class */ (function () {
    function AddressImporter() {
    }
    AddressImporter.prototype.fromMnemonic = function (mnemonic, seedPassword) {
        if (seedPassword === void 0) { seedPassword = ''; }
        var bip39 = new bip39_mnemonic_1.default(seedPassword);
        if (!bip39.validateMnemonic(mnemonic)) {
            throw new Error('Invalid mnemonic phrase');
        }
        var seed = bip39.mnemonicToSeed(mnemonic);
        return this.nano(seed, 0, 0, mnemonic);
    };
    AddressImporter.prototype.fromSeed = function (seed, from, to) {
        if (from === void 0) { from = 0; }
        if (to === void 0) { to = 0; }
        if (seed.length !== 128) {
            throw new Error('Invalid seed length, must be a 128 byte hexadecimal string');
        }
        if (!/^[0-9a-f]+$/i.test(seed)) {
            throw new Error('Seed is not a valid hexadecimal string');
        }
        return this.nano(seed, from, to, undefined);
    };
    /**
     * Generates the wallet
     * @param {String} seedPassword Password for the seed
     */
    AddressImporter.prototype.nano = function (seed, from, to, mnemonic) {
        var accounts = [];
        for (var i = from; i <= to; i++) {
            var bip44 = new bip32_key_derivation_1.default("44'/165'/" + i + "'", seed);
            var privateKey = bip44.derivePath().key;
            var ed25519 = new ed25519_1.default();
            var keyPair = ed25519.generateKeys(privateKey);
            var nano = new nano_address_1.default();
            var address = nano.deriveAddress(keyPair.publicKey);
            accounts.push({
                accountIndex: i,
                privateKey: keyPair.privateKey,
                publicKey: keyPair.publicKey,
                address: address,
            });
        }
        return {
            mnemonic: mnemonic,
            seed: seed,
            accounts: accounts,
        };
    };
    return AddressImporter;
}());
exports.default = AddressImporter;
