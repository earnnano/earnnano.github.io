"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var ed25519_1 = __importDefault(require("./ed25519"));
var convert_1 = __importDefault(require("./util/convert"));
var nano_address_1 = __importDefault(require("./nano-address"));
var nano_converter_1 = __importDefault(require("./nano-converter"));
//@ts-ignore
var blakejs_1 = require("blakejs");
var BlockSigner = /** @class */ (function () {
    function BlockSigner() {
        this.nanoAddress = new nano_address_1.default();
        this.ed25519 = new ed25519_1.default();
        this.preamble = 0x6.toString().padStart(64, '0');
    }
    BlockSigner.prototype.receive = function (data, privateKey) {
        var validateInputRaw = function (input) { return !!input && !isNaN(+input); };
        if (!validateInputRaw(data.walletBalanceRaw)) {
            throw new Error('Invalid format in wallet balance');
        }
        if (!validateInputRaw(data.amountRaw)) {
            throw new Error('Invalid format in send amount');
        }
        if (!this.nanoAddress.validateNanoAddress(data.toAddress)) {
            throw new Error('Invalid toAddress');
        }
        if (!this.nanoAddress.validateNanoAddress(data.representativeAddress)) {
            throw new Error('Invalid representativeAddress');
        }
        if (!data.transactionHash) {
            throw new Error('No transaction hash');
        }
        if (!data.frontier) {
            throw new Error('No frontier');
        }
        if (!data.work) {
            throw new Error('No work');
        }
        if (!privateKey) {
            throw new Error('Please input the private key to sign the block');
        }
        var balanceNano = nano_converter_1.default.convert(data.walletBalanceRaw, 'RAW', 'NANO');
        var amountNano = nano_converter_1.default.convert(data.amountRaw, 'RAW', 'NANO');
        var newBalanceNano = new bignumber_js_1.default(balanceNano).plus(new bignumber_js_1.default(amountNano));
        var newBalanceRaw = nano_converter_1.default.convert(newBalanceNano, 'NANO', 'RAW');
        var newBalanceHex = convert_1.default.dec2hex(newBalanceRaw, 16).toUpperCase();
        var account = this.nanoAddressToHexString(data.toAddress);
        var link = data.transactionHash;
        var representative = this.nanoAddressToHexString(data.representativeAddress);
        var signatureBytes = this.ed25519.sign(this.generateHash(this.preamble, account, data.frontier, representative, newBalanceHex, link), convert_1.default.hex2ab(privateKey));
        return {
            type: 'state',
            account: data.toAddress,
            previous: data.frontier,
            representative: data.representativeAddress,
            balance: newBalanceRaw,
            link: link,
            signature: convert_1.default.ab2hex(signatureBytes),
            work: data.work,
        };
    };
    BlockSigner.prototype.send = function (data, privateKey) {
        var validateInputRaw = function (input) { return !!input && !isNaN(+input); };
        if (!validateInputRaw(data.walletBalanceRaw)) {
            throw new Error('Invalid format in wallet balance');
        }
        if (!validateInputRaw(data.amountRaw)) {
            throw new Error('Invalid format in send amount');
        }
        if (!this.nanoAddress.validateNanoAddress(data.toAddress)) {
            throw new Error('Invalid toAddress');
        }
        if (!this.nanoAddress.validateNanoAddress(data.fromAddress)) {
            throw new Error('Invalid fromAddress');
        }
        if (!this.nanoAddress.validateNanoAddress(data.representativeAddress)) {
            throw new Error('Invalid representativeAddress');
        }
        if (!data.frontier) {
            throw new Error('No frontier');
        }
        if (!data.work) {
            throw new Error('No work');
        }
        if (!privateKey) {
            throw new Error('Please input the private key to sign the block');
        }
        var balanceNano = nano_converter_1.default.convert(data.walletBalanceRaw, 'RAW', 'NANO');
        var amountNano = nano_converter_1.default.convert(data.amountRaw, 'RAW', 'NANO');
        var newBalanceNano = new bignumber_js_1.default(balanceNano).minus(new bignumber_js_1.default(amountNano));
        var newBalanceRaw = nano_converter_1.default.convert(newBalanceNano, 'NANO', 'RAW');
        var newBalanceHex = convert_1.default.dec2hex(newBalanceRaw, 16).toUpperCase();
        var account = this.nanoAddressToHexString(data.fromAddress);
        var link = this.nanoAddressToHexString(data.toAddress);
        var representative = this.nanoAddressToHexString(data.representativeAddress);
        var signatureBytes = this.ed25519.sign(this.generateHash(this.preamble, account, data.frontier, representative, newBalanceHex, link), convert_1.default.hex2ab(privateKey));
        return {
            type: 'state',
            account: data.fromAddress,
            previous: data.frontier,
            representative: data.representativeAddress,
            balance: newBalanceRaw,
            link: link,
            signature: convert_1.default.ab2hex(signatureBytes),
            work: data.work,
        };
    };
    BlockSigner.prototype.generateHash = function (preamble, account, previous, representative, balance, link) {
        var ctx = blakejs_1.blake2bInit(32, undefined);
        blakejs_1.blake2bUpdate(ctx, convert_1.default.hex2ab(preamble));
        blakejs_1.blake2bUpdate(ctx, convert_1.default.hex2ab(account));
        blakejs_1.blake2bUpdate(ctx, convert_1.default.hex2ab(previous));
        blakejs_1.blake2bUpdate(ctx, convert_1.default.hex2ab(representative));
        blakejs_1.blake2bUpdate(ctx, convert_1.default.hex2ab(balance));
        blakejs_1.blake2bUpdate(ctx, convert_1.default.hex2ab(link));
        return blakejs_1.blake2bFinal(ctx);
    };
    BlockSigner.prototype.nanoAddressToHexString = function (addr) {
        addr = addr.slice(-60);
        var isValid = /^[13456789abcdefghijkmnopqrstuwxyz]+$/.test(addr);
        if (isValid) {
            var keyBytes = this.nanoAddress.decodeNanoBase32(addr.substring(0, 52));
            var hashBytes = this.nanoAddress.decodeNanoBase32(addr.substring(52, 60));
            var blakeHash = blakejs_1.blake2b(keyBytes, undefined, 5).reverse();
            if (convert_1.default.ab2hex(hashBytes) == convert_1.default.ab2hex(blakeHash)) {
                var key = convert_1.default.ab2hex(keyBytes).toUpperCase();
                return key;
            }
            throw new Error('Checksum mismatch');
        }
        else {
            throw new Error('Illegal characters');
        }
    };
    return BlockSigner;
}());
exports.default = BlockSigner;
