export default class Curve25519 {
    gf0: Int32Array;
    gf1: Int32Array;
    D: Int32Array;
    D2: Int32Array;
    I: Int32Array;
    _9: Uint8Array;
    _121665: Int32Array;
    constructor();
    gf(init?: number[]): Int32Array;
    A(o: Int32Array, a: Int32Array, b: Int32Array): void;
    Z(o: Int32Array, a: Int32Array, b: Int32Array): void;
    M(o: Int32Array, a: Int32Array, b: Int32Array): void;
    S(o: Int32Array, a: Int32Array): void;
    add(p: Int32Array[], q: Int32Array[]): void;
    set25519(r: Int32Array, a: Int32Array): void;
    car25519(o: Int32Array): void;
    sel25519(p: Int32Array, q: Int32Array, b: number): void;
    inv25519(o: Int32Array, i: Int32Array): void;
    neq25519(a: Int32Array, b: Int32Array): boolean;
    par25519(a: Int32Array): number;
    pow2523(o: Int32Array, i: Int32Array): void;
    cswap(p: Int32Array[], q: Int32Array[], b: number): void;
    pack25519(o: Uint8Array, n: Int32Array): void;
    unpack25519(o: Int32Array, n: Uint8Array): void;
    unpackNeg(r: Int32Array[], p: Uint8Array): number;
    /**
     * Internal scalar mult function
     * @param {Uint8Array} q Result
     * @param {Uint8Array} s Secret key
     * @param {Uint8Array} p Public key
     */
    cryptoScalarmult(q: Uint8Array, s: Uint8Array, p: Uint8Array): void;
    /**
     * Generate the common key as the produkt of sk1 * pk2
     * @param {Uint8Array} sk A 32 byte secret key of pair 1
     * @param {Uint8Array} pk A 32 byte public key of pair 2
     * @return {Uint8Array} sk * pk
     */
    scalarMult(sk: Uint8Array, pk: Uint8Array): Uint8Array;
    /**
     * Generate a curve 25519 keypair
     * @param {Uint8Array} seed A 32 byte cryptographic secure random array. This is basically the secret key
     * @param {Object} Returns sk (Secret key) and pk (Public key) as 32 byte typed arrays
     */
    generateKeys(seed: Uint8Array): {
        sk: Uint8Array;
        pk: Uint8Array;
    };
}
